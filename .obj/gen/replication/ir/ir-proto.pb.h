// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: replication/ir/ir-proto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_replication_2fir_2fir_2dproto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_replication_2fir_2fir_2dproto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "replication/common/request.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_replication_2fir_2fir_2dproto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_replication_2fir_2fir_2dproto_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_replication_2fir_2fir_2dproto_2eproto;
namespace replication {
namespace ir {
namespace proto {
class ConfirmMessage;
class ConfirmMessageDefaultTypeInternal;
extern ConfirmMessageDefaultTypeInternal _ConfirmMessage_default_instance_;
class DoViewChangeMessage;
class DoViewChangeMessageDefaultTypeInternal;
extern DoViewChangeMessageDefaultTypeInternal _DoViewChangeMessage_default_instance_;
class FinalizeConsensusMessage;
class FinalizeConsensusMessageDefaultTypeInternal;
extern FinalizeConsensusMessageDefaultTypeInternal _FinalizeConsensusMessage_default_instance_;
class FinalizeInconsistentMessage;
class FinalizeInconsistentMessageDefaultTypeInternal;
extern FinalizeInconsistentMessageDefaultTypeInternal _FinalizeInconsistentMessage_default_instance_;
class OpID;
class OpIDDefaultTypeInternal;
extern OpIDDefaultTypeInternal _OpID_default_instance_;
class PersistedViewInfo;
class PersistedViewInfoDefaultTypeInternal;
extern PersistedViewInfoDefaultTypeInternal _PersistedViewInfo_default_instance_;
class ProposeConsensusMessage;
class ProposeConsensusMessageDefaultTypeInternal;
extern ProposeConsensusMessageDefaultTypeInternal _ProposeConsensusMessage_default_instance_;
class ProposeInconsistentMessage;
class ProposeInconsistentMessageDefaultTypeInternal;
extern ProposeInconsistentMessageDefaultTypeInternal _ProposeInconsistentMessage_default_instance_;
class RecordEntryProto;
class RecordEntryProtoDefaultTypeInternal;
extern RecordEntryProtoDefaultTypeInternal _RecordEntryProto_default_instance_;
class RecordProto;
class RecordProtoDefaultTypeInternal;
extern RecordProtoDefaultTypeInternal _RecordProto_default_instance_;
class ReplyConsensusMessage;
class ReplyConsensusMessageDefaultTypeInternal;
extern ReplyConsensusMessageDefaultTypeInternal _ReplyConsensusMessage_default_instance_;
class ReplyInconsistentMessage;
class ReplyInconsistentMessageDefaultTypeInternal;
extern ReplyInconsistentMessageDefaultTypeInternal _ReplyInconsistentMessage_default_instance_;
class StartViewMessage;
class StartViewMessageDefaultTypeInternal;
extern StartViewMessageDefaultTypeInternal _StartViewMessage_default_instance_;
class UnloggedReplyMessage;
class UnloggedReplyMessageDefaultTypeInternal;
extern UnloggedReplyMessageDefaultTypeInternal _UnloggedReplyMessage_default_instance_;
class UnloggedRequestMessage;
class UnloggedRequestMessageDefaultTypeInternal;
extern UnloggedRequestMessageDefaultTypeInternal _UnloggedRequestMessage_default_instance_;
}  // namespace proto
}  // namespace ir
}  // namespace replication
PROTOBUF_NAMESPACE_OPEN
template<> ::replication::ir::proto::ConfirmMessage* Arena::CreateMaybeMessage<::replication::ir::proto::ConfirmMessage>(Arena*);
template<> ::replication::ir::proto::DoViewChangeMessage* Arena::CreateMaybeMessage<::replication::ir::proto::DoViewChangeMessage>(Arena*);
template<> ::replication::ir::proto::FinalizeConsensusMessage* Arena::CreateMaybeMessage<::replication::ir::proto::FinalizeConsensusMessage>(Arena*);
template<> ::replication::ir::proto::FinalizeInconsistentMessage* Arena::CreateMaybeMessage<::replication::ir::proto::FinalizeInconsistentMessage>(Arena*);
template<> ::replication::ir::proto::OpID* Arena::CreateMaybeMessage<::replication::ir::proto::OpID>(Arena*);
template<> ::replication::ir::proto::PersistedViewInfo* Arena::CreateMaybeMessage<::replication::ir::proto::PersistedViewInfo>(Arena*);
template<> ::replication::ir::proto::ProposeConsensusMessage* Arena::CreateMaybeMessage<::replication::ir::proto::ProposeConsensusMessage>(Arena*);
template<> ::replication::ir::proto::ProposeInconsistentMessage* Arena::CreateMaybeMessage<::replication::ir::proto::ProposeInconsistentMessage>(Arena*);
template<> ::replication::ir::proto::RecordEntryProto* Arena::CreateMaybeMessage<::replication::ir::proto::RecordEntryProto>(Arena*);
template<> ::replication::ir::proto::RecordProto* Arena::CreateMaybeMessage<::replication::ir::proto::RecordProto>(Arena*);
template<> ::replication::ir::proto::ReplyConsensusMessage* Arena::CreateMaybeMessage<::replication::ir::proto::ReplyConsensusMessage>(Arena*);
template<> ::replication::ir::proto::ReplyInconsistentMessage* Arena::CreateMaybeMessage<::replication::ir::proto::ReplyInconsistentMessage>(Arena*);
template<> ::replication::ir::proto::StartViewMessage* Arena::CreateMaybeMessage<::replication::ir::proto::StartViewMessage>(Arena*);
template<> ::replication::ir::proto::UnloggedReplyMessage* Arena::CreateMaybeMessage<::replication::ir::proto::UnloggedReplyMessage>(Arena*);
template<> ::replication::ir::proto::UnloggedRequestMessage* Arena::CreateMaybeMessage<::replication::ir::proto::UnloggedRequestMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace replication {
namespace ir {
namespace proto {

enum RecordEntryState : int {
  RECORD_STATE_TENTATIVE = 0,
  RECORD_STATE_FINALIZED = 1
};
bool RecordEntryState_IsValid(int value);
constexpr RecordEntryState RecordEntryState_MIN = RECORD_STATE_TENTATIVE;
constexpr RecordEntryState RecordEntryState_MAX = RECORD_STATE_FINALIZED;
constexpr int RecordEntryState_ARRAYSIZE = RecordEntryState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecordEntryState_descriptor();
template<typename T>
inline const std::string& RecordEntryState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecordEntryState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecordEntryState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecordEntryState_descriptor(), enum_t_value);
}
inline bool RecordEntryState_Parse(
    const std::string& name, RecordEntryState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecordEntryState>(
    RecordEntryState_descriptor(), name, value);
}
enum RecordEntryType : int {
  RECORD_TYPE_INCONSISTENT = 0,
  RECORD_TYPE_CONSENSUS = 1
};
bool RecordEntryType_IsValid(int value);
constexpr RecordEntryType RecordEntryType_MIN = RECORD_TYPE_INCONSISTENT;
constexpr RecordEntryType RecordEntryType_MAX = RECORD_TYPE_CONSENSUS;
constexpr int RecordEntryType_ARRAYSIZE = RecordEntryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RecordEntryType_descriptor();
template<typename T>
inline const std::string& RecordEntryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RecordEntryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RecordEntryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RecordEntryType_descriptor(), enum_t_value);
}
inline bool RecordEntryType_Parse(
    const std::string& name, RecordEntryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RecordEntryType>(
    RecordEntryType_descriptor(), name, value);
}
// ===================================================================

class OpID PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.OpID) */ {
 public:
  inline OpID() : OpID(nullptr) {};
  virtual ~OpID();

  OpID(const OpID& from);
  OpID(OpID&& from) noexcept
    : OpID() {
    *this = ::std::move(from);
  }

  inline OpID& operator=(const OpID& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpID& operator=(OpID&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OpID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpID* internal_default_instance() {
    return reinterpret_cast<const OpID*>(
               &_OpID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OpID& a, OpID& b) {
    a.Swap(&b);
  }
  inline void Swap(OpID* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpID* New() const final {
    return CreateMaybeMessage<OpID>(nullptr);
  }

  OpID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpID>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OpID& from);
  void MergeFrom(const OpID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.OpID";
  }
  protected:
  explicit OpID(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientidFieldNumber = 1,
    kClientreqidFieldNumber = 2,
  };
  // required uint64 clientid = 1;
  bool has_clientid() const;
  private:
  bool _internal_has_clientid() const;
  public:
  void clear_clientid();
  ::PROTOBUF_NAMESPACE_ID::uint64 clientid() const;
  void set_clientid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_clientid() const;
  void _internal_set_clientid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 clientreqid = 2;
  bool has_clientreqid() const;
  private:
  bool _internal_has_clientreqid() const;
  public:
  void clear_clientreqid();
  ::PROTOBUF_NAMESPACE_ID::uint64 clientreqid() const;
  void set_clientreqid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_clientreqid() const;
  void _internal_set_clientreqid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:replication.ir.proto.OpID)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 clientid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 clientreqid_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class PersistedViewInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.PersistedViewInfo) */ {
 public:
  inline PersistedViewInfo() : PersistedViewInfo(nullptr) {};
  virtual ~PersistedViewInfo();

  PersistedViewInfo(const PersistedViewInfo& from);
  PersistedViewInfo(PersistedViewInfo&& from) noexcept
    : PersistedViewInfo() {
    *this = ::std::move(from);
  }

  inline PersistedViewInfo& operator=(const PersistedViewInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PersistedViewInfo& operator=(PersistedViewInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PersistedViewInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PersistedViewInfo* internal_default_instance() {
    return reinterpret_cast<const PersistedViewInfo*>(
               &_PersistedViewInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PersistedViewInfo& a, PersistedViewInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PersistedViewInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PersistedViewInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PersistedViewInfo* New() const final {
    return CreateMaybeMessage<PersistedViewInfo>(nullptr);
  }

  PersistedViewInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PersistedViewInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PersistedViewInfo& from);
  void MergeFrom(const PersistedViewInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PersistedViewInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.PersistedViewInfo";
  }
  protected:
  explicit PersistedViewInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kViewFieldNumber = 1,
    kLatestNormalViewFieldNumber = 2,
  };
  // required uint64 view = 1;
  bool has_view() const;
  private:
  bool _internal_has_view() const;
  public:
  void clear_view();
  ::PROTOBUF_NAMESPACE_ID::uint64 view() const;
  void set_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_view() const;
  void _internal_set_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 latest_normal_view = 2;
  bool has_latest_normal_view() const;
  private:
  bool _internal_has_latest_normal_view() const;
  public:
  void clear_latest_normal_view();
  ::PROTOBUF_NAMESPACE_ID::uint64 latest_normal_view() const;
  void set_latest_normal_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_latest_normal_view() const;
  void _internal_set_latest_normal_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:replication.ir.proto.PersistedViewInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 view_;
  ::PROTOBUF_NAMESPACE_ID::uint64 latest_normal_view_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class RecordEntryProto PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.RecordEntryProto) */ {
 public:
  inline RecordEntryProto() : RecordEntryProto(nullptr) {};
  virtual ~RecordEntryProto();

  RecordEntryProto(const RecordEntryProto& from);
  RecordEntryProto(RecordEntryProto&& from) noexcept
    : RecordEntryProto() {
    *this = ::std::move(from);
  }

  inline RecordEntryProto& operator=(const RecordEntryProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordEntryProto& operator=(RecordEntryProto&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecordEntryProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordEntryProto* internal_default_instance() {
    return reinterpret_cast<const RecordEntryProto*>(
               &_RecordEntryProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RecordEntryProto& a, RecordEntryProto& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordEntryProto* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordEntryProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecordEntryProto* New() const final {
    return CreateMaybeMessage<RecordEntryProto>(nullptr);
  }

  RecordEntryProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecordEntryProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecordEntryProto& from);
  void MergeFrom(const RecordEntryProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordEntryProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.RecordEntryProto";
  }
  protected:
  explicit RecordEntryProto(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 5,
    kResultFieldNumber = 6,
    kOpidFieldNumber = 2,
    kViewFieldNumber = 1,
    kStateFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // required bytes op = 5;
  bool has_op() const;
  private:
  bool _internal_has_op() const;
  public:
  void clear_op();
  const std::string& op() const;
  void set_op(const std::string& value);
  void set_op(std::string&& value);
  void set_op(const char* value);
  void set_op(const void* value, size_t size);
  std::string* mutable_op();
  std::string* release_op();
  void set_allocated_op(std::string* op);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_op();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_op(
      std::string* op);
  private:
  const std::string& _internal_op() const;
  void _internal_set_op(const std::string& value);
  std::string* _internal_mutable_op();
  public:

  // required bytes result = 6;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const std::string& result() const;
  void set_result(const std::string& value);
  void set_result(std::string&& value);
  void set_result(const char* value);
  void set_result(const void* value, size_t size);
  std::string* mutable_result();
  std::string* release_result();
  void set_allocated_result(std::string* result);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_result();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_result(
      std::string* result);
  private:
  const std::string& _internal_result() const;
  void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // required .replication.ir.proto.OpID opid = 2;
  bool has_opid() const;
  private:
  bool _internal_has_opid() const;
  public:
  void clear_opid();
  const ::replication::ir::proto::OpID& opid() const;
  ::replication::ir::proto::OpID* release_opid();
  ::replication::ir::proto::OpID* mutable_opid();
  void set_allocated_opid(::replication::ir::proto::OpID* opid);
  private:
  const ::replication::ir::proto::OpID& _internal_opid() const;
  ::replication::ir::proto::OpID* _internal_mutable_opid();
  public:
  void unsafe_arena_set_allocated_opid(
      ::replication::ir::proto::OpID* opid);
  ::replication::ir::proto::OpID* unsafe_arena_release_opid();

  // required uint64 view = 1;
  bool has_view() const;
  private:
  bool _internal_has_view() const;
  public:
  void clear_view();
  ::PROTOBUF_NAMESPACE_ID::uint64 view() const;
  void set_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_view() const;
  void _internal_set_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required .replication.ir.proto.RecordEntryState state = 3;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::replication::ir::proto::RecordEntryState state() const;
  void set_state(::replication::ir::proto::RecordEntryState value);
  private:
  ::replication::ir::proto::RecordEntryState _internal_state() const;
  void _internal_set_state(::replication::ir::proto::RecordEntryState value);
  public:

  // required .replication.ir.proto.RecordEntryType type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::replication::ir::proto::RecordEntryType type() const;
  void set_type(::replication::ir::proto::RecordEntryType value);
  private:
  ::replication::ir::proto::RecordEntryType _internal_type() const;
  void _internal_set_type(::replication::ir::proto::RecordEntryType value);
  public:

  // @@protoc_insertion_point(class_scope:replication.ir.proto.RecordEntryProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  ::replication::ir::proto::OpID* opid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 view_;
  int state_;
  int type_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class RecordProto PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.RecordProto) */ {
 public:
  inline RecordProto() : RecordProto(nullptr) {};
  virtual ~RecordProto();

  RecordProto(const RecordProto& from);
  RecordProto(RecordProto&& from) noexcept
    : RecordProto() {
    *this = ::std::move(from);
  }

  inline RecordProto& operator=(const RecordProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordProto& operator=(RecordProto&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecordProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordProto* internal_default_instance() {
    return reinterpret_cast<const RecordProto*>(
               &_RecordProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RecordProto& a, RecordProto& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordProto* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecordProto* New() const final {
    return CreateMaybeMessage<RecordProto>(nullptr);
  }

  RecordProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecordProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecordProto& from);
  void MergeFrom(const RecordProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.RecordProto";
  }
  protected:
  explicit RecordProto(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryFieldNumber = 1,
  };
  // repeated .replication.ir.proto.RecordEntryProto entry = 1;
  int entry_size() const;
  private:
  int _internal_entry_size() const;
  public:
  void clear_entry();
  ::replication::ir::proto::RecordEntryProto* mutable_entry(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::replication::ir::proto::RecordEntryProto >*
      mutable_entry();
  private:
  const ::replication::ir::proto::RecordEntryProto& _internal_entry(int index) const;
  ::replication::ir::proto::RecordEntryProto* _internal_add_entry();
  public:
  const ::replication::ir::proto::RecordEntryProto& entry(int index) const;
  ::replication::ir::proto::RecordEntryProto* add_entry();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::replication::ir::proto::RecordEntryProto >&
      entry() const;

  // @@protoc_insertion_point(class_scope:replication.ir.proto.RecordProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::replication::ir::proto::RecordEntryProto > entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class ProposeInconsistentMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.ProposeInconsistentMessage) */ {
 public:
  inline ProposeInconsistentMessage() : ProposeInconsistentMessage(nullptr) {};
  virtual ~ProposeInconsistentMessage();

  ProposeInconsistentMessage(const ProposeInconsistentMessage& from);
  ProposeInconsistentMessage(ProposeInconsistentMessage&& from) noexcept
    : ProposeInconsistentMessage() {
    *this = ::std::move(from);
  }

  inline ProposeInconsistentMessage& operator=(const ProposeInconsistentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposeInconsistentMessage& operator=(ProposeInconsistentMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProposeInconsistentMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProposeInconsistentMessage* internal_default_instance() {
    return reinterpret_cast<const ProposeInconsistentMessage*>(
               &_ProposeInconsistentMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ProposeInconsistentMessage& a, ProposeInconsistentMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposeInconsistentMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposeInconsistentMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProposeInconsistentMessage* New() const final {
    return CreateMaybeMessage<ProposeInconsistentMessage>(nullptr);
  }

  ProposeInconsistentMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProposeInconsistentMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProposeInconsistentMessage& from);
  void MergeFrom(const ProposeInconsistentMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposeInconsistentMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.ProposeInconsistentMessage";
  }
  protected:
  explicit ProposeInconsistentMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 1,
  };
  // required .replication.Request req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::replication::Request& req() const;
  ::replication::Request* release_req();
  ::replication::Request* mutable_req();
  void set_allocated_req(::replication::Request* req);
  private:
  const ::replication::Request& _internal_req() const;
  ::replication::Request* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::replication::Request* req);
  ::replication::Request* unsafe_arena_release_req();

  // @@protoc_insertion_point(class_scope:replication.ir.proto.ProposeInconsistentMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::replication::Request* req_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class ReplyInconsistentMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.ReplyInconsistentMessage) */ {
 public:
  inline ReplyInconsistentMessage() : ReplyInconsistentMessage(nullptr) {};
  virtual ~ReplyInconsistentMessage();

  ReplyInconsistentMessage(const ReplyInconsistentMessage& from);
  ReplyInconsistentMessage(ReplyInconsistentMessage&& from) noexcept
    : ReplyInconsistentMessage() {
    *this = ::std::move(from);
  }

  inline ReplyInconsistentMessage& operator=(const ReplyInconsistentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplyInconsistentMessage& operator=(ReplyInconsistentMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReplyInconsistentMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplyInconsistentMessage* internal_default_instance() {
    return reinterpret_cast<const ReplyInconsistentMessage*>(
               &_ReplyInconsistentMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReplyInconsistentMessage& a, ReplyInconsistentMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplyInconsistentMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplyInconsistentMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReplyInconsistentMessage* New() const final {
    return CreateMaybeMessage<ReplyInconsistentMessage>(nullptr);
  }

  ReplyInconsistentMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReplyInconsistentMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReplyInconsistentMessage& from);
  void MergeFrom(const ReplyInconsistentMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplyInconsistentMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.ReplyInconsistentMessage";
  }
  protected:
  explicit ReplyInconsistentMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpidFieldNumber = 3,
    kViewFieldNumber = 1,
    kReplicaIdxFieldNumber = 2,
    kFinalizedFieldNumber = 4,
  };
  // required .replication.ir.proto.OpID opid = 3;
  bool has_opid() const;
  private:
  bool _internal_has_opid() const;
  public:
  void clear_opid();
  const ::replication::ir::proto::OpID& opid() const;
  ::replication::ir::proto::OpID* release_opid();
  ::replication::ir::proto::OpID* mutable_opid();
  void set_allocated_opid(::replication::ir::proto::OpID* opid);
  private:
  const ::replication::ir::proto::OpID& _internal_opid() const;
  ::replication::ir::proto::OpID* _internal_mutable_opid();
  public:
  void unsafe_arena_set_allocated_opid(
      ::replication::ir::proto::OpID* opid);
  ::replication::ir::proto::OpID* unsafe_arena_release_opid();

  // required uint64 view = 1;
  bool has_view() const;
  private:
  bool _internal_has_view() const;
  public:
  void clear_view();
  ::PROTOBUF_NAMESPACE_ID::uint64 view() const;
  void set_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_view() const;
  void _internal_set_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint32 replicaIdx = 2;
  bool has_replicaidx() const;
  private:
  bool _internal_has_replicaidx() const;
  public:
  void clear_replicaidx();
  ::PROTOBUF_NAMESPACE_ID::uint32 replicaidx() const;
  void set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_replicaidx() const;
  void _internal_set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required bool finalized = 4;
  bool has_finalized() const;
  private:
  bool _internal_has_finalized() const;
  public:
  void clear_finalized();
  bool finalized() const;
  void set_finalized(bool value);
  private:
  bool _internal_finalized() const;
  void _internal_set_finalized(bool value);
  public:

  // @@protoc_insertion_point(class_scope:replication.ir.proto.ReplyInconsistentMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::replication::ir::proto::OpID* opid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 view_;
  ::PROTOBUF_NAMESPACE_ID::uint32 replicaidx_;
  bool finalized_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class FinalizeInconsistentMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.FinalizeInconsistentMessage) */ {
 public:
  inline FinalizeInconsistentMessage() : FinalizeInconsistentMessage(nullptr) {};
  virtual ~FinalizeInconsistentMessage();

  FinalizeInconsistentMessage(const FinalizeInconsistentMessage& from);
  FinalizeInconsistentMessage(FinalizeInconsistentMessage&& from) noexcept
    : FinalizeInconsistentMessage() {
    *this = ::std::move(from);
  }

  inline FinalizeInconsistentMessage& operator=(const FinalizeInconsistentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinalizeInconsistentMessage& operator=(FinalizeInconsistentMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FinalizeInconsistentMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FinalizeInconsistentMessage* internal_default_instance() {
    return reinterpret_cast<const FinalizeInconsistentMessage*>(
               &_FinalizeInconsistentMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FinalizeInconsistentMessage& a, FinalizeInconsistentMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FinalizeInconsistentMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinalizeInconsistentMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FinalizeInconsistentMessage* New() const final {
    return CreateMaybeMessage<FinalizeInconsistentMessage>(nullptr);
  }

  FinalizeInconsistentMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FinalizeInconsistentMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FinalizeInconsistentMessage& from);
  void MergeFrom(const FinalizeInconsistentMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinalizeInconsistentMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.FinalizeInconsistentMessage";
  }
  protected:
  explicit FinalizeInconsistentMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpidFieldNumber = 1,
  };
  // required .replication.ir.proto.OpID opid = 1;
  bool has_opid() const;
  private:
  bool _internal_has_opid() const;
  public:
  void clear_opid();
  const ::replication::ir::proto::OpID& opid() const;
  ::replication::ir::proto::OpID* release_opid();
  ::replication::ir::proto::OpID* mutable_opid();
  void set_allocated_opid(::replication::ir::proto::OpID* opid);
  private:
  const ::replication::ir::proto::OpID& _internal_opid() const;
  ::replication::ir::proto::OpID* _internal_mutable_opid();
  public:
  void unsafe_arena_set_allocated_opid(
      ::replication::ir::proto::OpID* opid);
  ::replication::ir::proto::OpID* unsafe_arena_release_opid();

  // @@protoc_insertion_point(class_scope:replication.ir.proto.FinalizeInconsistentMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::replication::ir::proto::OpID* opid_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class ConfirmMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.ConfirmMessage) */ {
 public:
  inline ConfirmMessage() : ConfirmMessage(nullptr) {};
  virtual ~ConfirmMessage();

  ConfirmMessage(const ConfirmMessage& from);
  ConfirmMessage(ConfirmMessage&& from) noexcept
    : ConfirmMessage() {
    *this = ::std::move(from);
  }

  inline ConfirmMessage& operator=(const ConfirmMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmMessage& operator=(ConfirmMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConfirmMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfirmMessage* internal_default_instance() {
    return reinterpret_cast<const ConfirmMessage*>(
               &_ConfirmMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ConfirmMessage& a, ConfirmMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfirmMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConfirmMessage* New() const final {
    return CreateMaybeMessage<ConfirmMessage>(nullptr);
  }

  ConfirmMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConfirmMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConfirmMessage& from);
  void MergeFrom(const ConfirmMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfirmMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.ConfirmMessage";
  }
  protected:
  explicit ConfirmMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpidFieldNumber = 3,
    kViewFieldNumber = 1,
    kReplicaIdxFieldNumber = 2,
  };
  // required .replication.ir.proto.OpID opid = 3;
  bool has_opid() const;
  private:
  bool _internal_has_opid() const;
  public:
  void clear_opid();
  const ::replication::ir::proto::OpID& opid() const;
  ::replication::ir::proto::OpID* release_opid();
  ::replication::ir::proto::OpID* mutable_opid();
  void set_allocated_opid(::replication::ir::proto::OpID* opid);
  private:
  const ::replication::ir::proto::OpID& _internal_opid() const;
  ::replication::ir::proto::OpID* _internal_mutable_opid();
  public:
  void unsafe_arena_set_allocated_opid(
      ::replication::ir::proto::OpID* opid);
  ::replication::ir::proto::OpID* unsafe_arena_release_opid();

  // required uint64 view = 1;
  bool has_view() const;
  private:
  bool _internal_has_view() const;
  public:
  void clear_view();
  ::PROTOBUF_NAMESPACE_ID::uint64 view() const;
  void set_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_view() const;
  void _internal_set_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint32 replicaIdx = 2;
  bool has_replicaidx() const;
  private:
  bool _internal_has_replicaidx() const;
  public:
  void clear_replicaidx();
  ::PROTOBUF_NAMESPACE_ID::uint32 replicaidx() const;
  void set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_replicaidx() const;
  void _internal_set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:replication.ir.proto.ConfirmMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::replication::ir::proto::OpID* opid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 view_;
  ::PROTOBUF_NAMESPACE_ID::uint32 replicaidx_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class ProposeConsensusMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.ProposeConsensusMessage) */ {
 public:
  inline ProposeConsensusMessage() : ProposeConsensusMessage(nullptr) {};
  virtual ~ProposeConsensusMessage();

  ProposeConsensusMessage(const ProposeConsensusMessage& from);
  ProposeConsensusMessage(ProposeConsensusMessage&& from) noexcept
    : ProposeConsensusMessage() {
    *this = ::std::move(from);
  }

  inline ProposeConsensusMessage& operator=(const ProposeConsensusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProposeConsensusMessage& operator=(ProposeConsensusMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProposeConsensusMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProposeConsensusMessage* internal_default_instance() {
    return reinterpret_cast<const ProposeConsensusMessage*>(
               &_ProposeConsensusMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProposeConsensusMessage& a, ProposeConsensusMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ProposeConsensusMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProposeConsensusMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProposeConsensusMessage* New() const final {
    return CreateMaybeMessage<ProposeConsensusMessage>(nullptr);
  }

  ProposeConsensusMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProposeConsensusMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProposeConsensusMessage& from);
  void MergeFrom(const ProposeConsensusMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProposeConsensusMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.ProposeConsensusMessage";
  }
  protected:
  explicit ProposeConsensusMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 1,
  };
  // required .replication.Request req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::replication::Request& req() const;
  ::replication::Request* release_req();
  ::replication::Request* mutable_req();
  void set_allocated_req(::replication::Request* req);
  private:
  const ::replication::Request& _internal_req() const;
  ::replication::Request* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::replication::Request* req);
  ::replication::Request* unsafe_arena_release_req();

  // @@protoc_insertion_point(class_scope:replication.ir.proto.ProposeConsensusMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::replication::Request* req_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class ReplyConsensusMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.ReplyConsensusMessage) */ {
 public:
  inline ReplyConsensusMessage() : ReplyConsensusMessage(nullptr) {};
  virtual ~ReplyConsensusMessage();

  ReplyConsensusMessage(const ReplyConsensusMessage& from);
  ReplyConsensusMessage(ReplyConsensusMessage&& from) noexcept
    : ReplyConsensusMessage() {
    *this = ::std::move(from);
  }

  inline ReplyConsensusMessage& operator=(const ReplyConsensusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplyConsensusMessage& operator=(ReplyConsensusMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReplyConsensusMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplyConsensusMessage* internal_default_instance() {
    return reinterpret_cast<const ReplyConsensusMessage*>(
               &_ReplyConsensusMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReplyConsensusMessage& a, ReplyConsensusMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplyConsensusMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplyConsensusMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReplyConsensusMessage* New() const final {
    return CreateMaybeMessage<ReplyConsensusMessage>(nullptr);
  }

  ReplyConsensusMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReplyConsensusMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReplyConsensusMessage& from);
  void MergeFrom(const ReplyConsensusMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplyConsensusMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.ReplyConsensusMessage";
  }
  protected:
  explicit ReplyConsensusMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 4,
    kOpidFieldNumber = 3,
    kViewFieldNumber = 1,
    kReplicaIdxFieldNumber = 2,
    kFinalizedFieldNumber = 5,
  };
  // required bytes result = 4;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const std::string& result() const;
  void set_result(const std::string& value);
  void set_result(std::string&& value);
  void set_result(const char* value);
  void set_result(const void* value, size_t size);
  std::string* mutable_result();
  std::string* release_result();
  void set_allocated_result(std::string* result);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_result();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_result(
      std::string* result);
  private:
  const std::string& _internal_result() const;
  void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // required .replication.ir.proto.OpID opid = 3;
  bool has_opid() const;
  private:
  bool _internal_has_opid() const;
  public:
  void clear_opid();
  const ::replication::ir::proto::OpID& opid() const;
  ::replication::ir::proto::OpID* release_opid();
  ::replication::ir::proto::OpID* mutable_opid();
  void set_allocated_opid(::replication::ir::proto::OpID* opid);
  private:
  const ::replication::ir::proto::OpID& _internal_opid() const;
  ::replication::ir::proto::OpID* _internal_mutable_opid();
  public:
  void unsafe_arena_set_allocated_opid(
      ::replication::ir::proto::OpID* opid);
  ::replication::ir::proto::OpID* unsafe_arena_release_opid();

  // required uint64 view = 1;
  bool has_view() const;
  private:
  bool _internal_has_view() const;
  public:
  void clear_view();
  ::PROTOBUF_NAMESPACE_ID::uint64 view() const;
  void set_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_view() const;
  void _internal_set_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint32 replicaIdx = 2;
  bool has_replicaidx() const;
  private:
  bool _internal_has_replicaidx() const;
  public:
  void clear_replicaidx();
  ::PROTOBUF_NAMESPACE_ID::uint32 replicaidx() const;
  void set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_replicaidx() const;
  void _internal_set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required bool finalized = 5;
  bool has_finalized() const;
  private:
  bool _internal_has_finalized() const;
  public:
  void clear_finalized();
  bool finalized() const;
  void set_finalized(bool value);
  private:
  bool _internal_finalized() const;
  void _internal_set_finalized(bool value);
  public:

  // @@protoc_insertion_point(class_scope:replication.ir.proto.ReplyConsensusMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  ::replication::ir::proto::OpID* opid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 view_;
  ::PROTOBUF_NAMESPACE_ID::uint32 replicaidx_;
  bool finalized_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class FinalizeConsensusMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.FinalizeConsensusMessage) */ {
 public:
  inline FinalizeConsensusMessage() : FinalizeConsensusMessage(nullptr) {};
  virtual ~FinalizeConsensusMessage();

  FinalizeConsensusMessage(const FinalizeConsensusMessage& from);
  FinalizeConsensusMessage(FinalizeConsensusMessage&& from) noexcept
    : FinalizeConsensusMessage() {
    *this = ::std::move(from);
  }

  inline FinalizeConsensusMessage& operator=(const FinalizeConsensusMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinalizeConsensusMessage& operator=(FinalizeConsensusMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FinalizeConsensusMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FinalizeConsensusMessage* internal_default_instance() {
    return reinterpret_cast<const FinalizeConsensusMessage*>(
               &_FinalizeConsensusMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FinalizeConsensusMessage& a, FinalizeConsensusMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FinalizeConsensusMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinalizeConsensusMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FinalizeConsensusMessage* New() const final {
    return CreateMaybeMessage<FinalizeConsensusMessage>(nullptr);
  }

  FinalizeConsensusMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FinalizeConsensusMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FinalizeConsensusMessage& from);
  void MergeFrom(const FinalizeConsensusMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinalizeConsensusMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.FinalizeConsensusMessage";
  }
  protected:
  explicit FinalizeConsensusMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kOpidFieldNumber = 1,
  };
  // required bytes result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const std::string& result() const;
  void set_result(const std::string& value);
  void set_result(std::string&& value);
  void set_result(const char* value);
  void set_result(const void* value, size_t size);
  std::string* mutable_result();
  std::string* release_result();
  void set_allocated_result(std::string* result);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_result();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_result(
      std::string* result);
  private:
  const std::string& _internal_result() const;
  void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // required .replication.ir.proto.OpID opid = 1;
  bool has_opid() const;
  private:
  bool _internal_has_opid() const;
  public:
  void clear_opid();
  const ::replication::ir::proto::OpID& opid() const;
  ::replication::ir::proto::OpID* release_opid();
  ::replication::ir::proto::OpID* mutable_opid();
  void set_allocated_opid(::replication::ir::proto::OpID* opid);
  private:
  const ::replication::ir::proto::OpID& _internal_opid() const;
  ::replication::ir::proto::OpID* _internal_mutable_opid();
  public:
  void unsafe_arena_set_allocated_opid(
      ::replication::ir::proto::OpID* opid);
  ::replication::ir::proto::OpID* unsafe_arena_release_opid();

  // @@protoc_insertion_point(class_scope:replication.ir.proto.FinalizeConsensusMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  ::replication::ir::proto::OpID* opid_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class DoViewChangeMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.DoViewChangeMessage) */ {
 public:
  inline DoViewChangeMessage() : DoViewChangeMessage(nullptr) {};
  virtual ~DoViewChangeMessage();

  DoViewChangeMessage(const DoViewChangeMessage& from);
  DoViewChangeMessage(DoViewChangeMessage&& from) noexcept
    : DoViewChangeMessage() {
    *this = ::std::move(from);
  }

  inline DoViewChangeMessage& operator=(const DoViewChangeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoViewChangeMessage& operator=(DoViewChangeMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DoViewChangeMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoViewChangeMessage* internal_default_instance() {
    return reinterpret_cast<const DoViewChangeMessage*>(
               &_DoViewChangeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DoViewChangeMessage& a, DoViewChangeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DoViewChangeMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoViewChangeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DoViewChangeMessage* New() const final {
    return CreateMaybeMessage<DoViewChangeMessage>(nullptr);
  }

  DoViewChangeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DoViewChangeMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DoViewChangeMessage& from);
  void MergeFrom(const DoViewChangeMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoViewChangeMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.DoViewChangeMessage";
  }
  protected:
  explicit DoViewChangeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordFieldNumber = 2,
    kNewViewFieldNumber = 3,
    kLatestNormalViewFieldNumber = 4,
    kReplicaIdxFieldNumber = 1,
  };
  // optional .replication.ir.proto.RecordProto record = 2;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::replication::ir::proto::RecordProto& record() const;
  ::replication::ir::proto::RecordProto* release_record();
  ::replication::ir::proto::RecordProto* mutable_record();
  void set_allocated_record(::replication::ir::proto::RecordProto* record);
  private:
  const ::replication::ir::proto::RecordProto& _internal_record() const;
  ::replication::ir::proto::RecordProto* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::replication::ir::proto::RecordProto* record);
  ::replication::ir::proto::RecordProto* unsafe_arena_release_record();

  // required uint64 new_view = 3;
  bool has_new_view() const;
  private:
  bool _internal_has_new_view() const;
  public:
  void clear_new_view();
  ::PROTOBUF_NAMESPACE_ID::uint64 new_view() const;
  void set_new_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_new_view() const;
  void _internal_set_new_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint64 latest_normal_view = 4;
  bool has_latest_normal_view() const;
  private:
  bool _internal_has_latest_normal_view() const;
  public:
  void clear_latest_normal_view();
  ::PROTOBUF_NAMESPACE_ID::uint64 latest_normal_view() const;
  void set_latest_normal_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_latest_normal_view() const;
  void _internal_set_latest_normal_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // required uint32 replicaIdx = 1;
  bool has_replicaidx() const;
  private:
  bool _internal_has_replicaidx() const;
  public:
  void clear_replicaidx();
  ::PROTOBUF_NAMESPACE_ID::uint32 replicaidx() const;
  void set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_replicaidx() const;
  void _internal_set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:replication.ir.proto.DoViewChangeMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::replication::ir::proto::RecordProto* record_;
  ::PROTOBUF_NAMESPACE_ID::uint64 new_view_;
  ::PROTOBUF_NAMESPACE_ID::uint64 latest_normal_view_;
  ::PROTOBUF_NAMESPACE_ID::uint32 replicaidx_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class StartViewMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.StartViewMessage) */ {
 public:
  inline StartViewMessage() : StartViewMessage(nullptr) {};
  virtual ~StartViewMessage();

  StartViewMessage(const StartViewMessage& from);
  StartViewMessage(StartViewMessage&& from) noexcept
    : StartViewMessage() {
    *this = ::std::move(from);
  }

  inline StartViewMessage& operator=(const StartViewMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartViewMessage& operator=(StartViewMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StartViewMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartViewMessage* internal_default_instance() {
    return reinterpret_cast<const StartViewMessage*>(
               &_StartViewMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StartViewMessage& a, StartViewMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(StartViewMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartViewMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartViewMessage* New() const final {
    return CreateMaybeMessage<StartViewMessage>(nullptr);
  }

  StartViewMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartViewMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StartViewMessage& from);
  void MergeFrom(const StartViewMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartViewMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.StartViewMessage";
  }
  protected:
  explicit StartViewMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordFieldNumber = 1,
    kNewViewFieldNumber = 2,
  };
  // required .replication.ir.proto.RecordProto record = 1;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::replication::ir::proto::RecordProto& record() const;
  ::replication::ir::proto::RecordProto* release_record();
  ::replication::ir::proto::RecordProto* mutable_record();
  void set_allocated_record(::replication::ir::proto::RecordProto* record);
  private:
  const ::replication::ir::proto::RecordProto& _internal_record() const;
  ::replication::ir::proto::RecordProto* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::replication::ir::proto::RecordProto* record);
  ::replication::ir::proto::RecordProto* unsafe_arena_release_record();

  // required uint64 new_view = 2;
  bool has_new_view() const;
  private:
  bool _internal_has_new_view() const;
  public:
  void clear_new_view();
  ::PROTOBUF_NAMESPACE_ID::uint64 new_view() const;
  void set_new_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_new_view() const;
  void _internal_set_new_view(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:replication.ir.proto.StartViewMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::replication::ir::proto::RecordProto* record_;
  ::PROTOBUF_NAMESPACE_ID::uint64 new_view_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class UnloggedRequestMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.UnloggedRequestMessage) */ {
 public:
  inline UnloggedRequestMessage() : UnloggedRequestMessage(nullptr) {};
  virtual ~UnloggedRequestMessage();

  UnloggedRequestMessage(const UnloggedRequestMessage& from);
  UnloggedRequestMessage(UnloggedRequestMessage&& from) noexcept
    : UnloggedRequestMessage() {
    *this = ::std::move(from);
  }

  inline UnloggedRequestMessage& operator=(const UnloggedRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnloggedRequestMessage& operator=(UnloggedRequestMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnloggedRequestMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnloggedRequestMessage* internal_default_instance() {
    return reinterpret_cast<const UnloggedRequestMessage*>(
               &_UnloggedRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UnloggedRequestMessage& a, UnloggedRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(UnloggedRequestMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnloggedRequestMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnloggedRequestMessage* New() const final {
    return CreateMaybeMessage<UnloggedRequestMessage>(nullptr);
  }

  UnloggedRequestMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnloggedRequestMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnloggedRequestMessage& from);
  void MergeFrom(const UnloggedRequestMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnloggedRequestMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.UnloggedRequestMessage";
  }
  protected:
  explicit UnloggedRequestMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqFieldNumber = 1,
  };
  // required .replication.UnloggedRequest req = 1;
  bool has_req() const;
  private:
  bool _internal_has_req() const;
  public:
  void clear_req();
  const ::replication::UnloggedRequest& req() const;
  ::replication::UnloggedRequest* release_req();
  ::replication::UnloggedRequest* mutable_req();
  void set_allocated_req(::replication::UnloggedRequest* req);
  private:
  const ::replication::UnloggedRequest& _internal_req() const;
  ::replication::UnloggedRequest* _internal_mutable_req();
  public:
  void unsafe_arena_set_allocated_req(
      ::replication::UnloggedRequest* req);
  ::replication::UnloggedRequest* unsafe_arena_release_req();

  // @@protoc_insertion_point(class_scope:replication.ir.proto.UnloggedRequestMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::replication::UnloggedRequest* req_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// -------------------------------------------------------------------

class UnloggedReplyMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:replication.ir.proto.UnloggedReplyMessage) */ {
 public:
  inline UnloggedReplyMessage() : UnloggedReplyMessage(nullptr) {};
  virtual ~UnloggedReplyMessage();

  UnloggedReplyMessage(const UnloggedReplyMessage& from);
  UnloggedReplyMessage(UnloggedReplyMessage&& from) noexcept
    : UnloggedReplyMessage() {
    *this = ::std::move(from);
  }

  inline UnloggedReplyMessage& operator=(const UnloggedReplyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnloggedReplyMessage& operator=(UnloggedReplyMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnloggedReplyMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnloggedReplyMessage* internal_default_instance() {
    return reinterpret_cast<const UnloggedReplyMessage*>(
               &_UnloggedReplyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UnloggedReplyMessage& a, UnloggedReplyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(UnloggedReplyMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnloggedReplyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnloggedReplyMessage* New() const final {
    return CreateMaybeMessage<UnloggedReplyMessage>(nullptr);
  }

  UnloggedReplyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnloggedReplyMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnloggedReplyMessage& from);
  void MergeFrom(const UnloggedReplyMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnloggedReplyMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "replication.ir.proto.UnloggedReplyMessage";
  }
  protected:
  explicit UnloggedReplyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_replication_2fir_2fir_2dproto_2eproto);
    return ::descriptor_table_replication_2fir_2fir_2dproto_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyFieldNumber = 1,
    kClientreqidFieldNumber = 2,
  };
  // required bytes reply = 1;
  bool has_reply() const;
  private:
  bool _internal_has_reply() const;
  public:
  void clear_reply();
  const std::string& reply() const;
  void set_reply(const std::string& value);
  void set_reply(std::string&& value);
  void set_reply(const char* value);
  void set_reply(const void* value, size_t size);
  std::string* mutable_reply();
  std::string* release_reply();
  void set_allocated_reply(std::string* reply);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_reply();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_reply(
      std::string* reply);
  private:
  const std::string& _internal_reply() const;
  void _internal_set_reply(const std::string& value);
  std::string* _internal_mutable_reply();
  public:

  // required uint64 clientreqid = 2;
  bool has_clientreqid() const;
  private:
  bool _internal_has_clientreqid() const;
  public:
  void clear_clientreqid();
  ::PROTOBUF_NAMESPACE_ID::uint64 clientreqid() const;
  void set_clientreqid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_clientreqid() const;
  void _internal_set_clientreqid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:replication.ir.proto.UnloggedReplyMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_;
  ::PROTOBUF_NAMESPACE_ID::uint64 clientreqid_;
  friend struct ::TableStruct_replication_2fir_2fir_2dproto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OpID

// required uint64 clientid = 1;
inline bool OpID::_internal_has_clientid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OpID::has_clientid() const {
  return _internal_has_clientid();
}
inline void OpID::clear_clientid() {
  clientid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpID::_internal_clientid() const {
  return clientid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpID::clientid() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.OpID.clientid)
  return _internal_clientid();
}
inline void OpID::_internal_set_clientid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  clientid_ = value;
}
inline void OpID::set_clientid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.OpID.clientid)
}

// required uint64 clientreqid = 2;
inline bool OpID::_internal_has_clientreqid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OpID::has_clientreqid() const {
  return _internal_has_clientreqid();
}
inline void OpID::clear_clientreqid() {
  clientreqid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpID::_internal_clientreqid() const {
  return clientreqid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpID::clientreqid() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.OpID.clientreqid)
  return _internal_clientreqid();
}
inline void OpID::_internal_set_clientreqid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  clientreqid_ = value;
}
inline void OpID::set_clientreqid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_clientreqid(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.OpID.clientreqid)
}

// -------------------------------------------------------------------

// PersistedViewInfo

// required uint64 view = 1;
inline bool PersistedViewInfo::_internal_has_view() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PersistedViewInfo::has_view() const {
  return _internal_has_view();
}
inline void PersistedViewInfo::clear_view() {
  view_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PersistedViewInfo::_internal_view() const {
  return view_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PersistedViewInfo::view() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.PersistedViewInfo.view)
  return _internal_view();
}
inline void PersistedViewInfo::_internal_set_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  view_ = value;
}
inline void PersistedViewInfo::set_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_view(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.PersistedViewInfo.view)
}

// required uint64 latest_normal_view = 2;
inline bool PersistedViewInfo::_internal_has_latest_normal_view() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PersistedViewInfo::has_latest_normal_view() const {
  return _internal_has_latest_normal_view();
}
inline void PersistedViewInfo::clear_latest_normal_view() {
  latest_normal_view_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PersistedViewInfo::_internal_latest_normal_view() const {
  return latest_normal_view_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PersistedViewInfo::latest_normal_view() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.PersistedViewInfo.latest_normal_view)
  return _internal_latest_normal_view();
}
inline void PersistedViewInfo::_internal_set_latest_normal_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  latest_normal_view_ = value;
}
inline void PersistedViewInfo::set_latest_normal_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_latest_normal_view(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.PersistedViewInfo.latest_normal_view)
}

// -------------------------------------------------------------------

// RecordEntryProto

// required uint64 view = 1;
inline bool RecordEntryProto::_internal_has_view() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RecordEntryProto::has_view() const {
  return _internal_has_view();
}
inline void RecordEntryProto::clear_view() {
  view_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RecordEntryProto::_internal_view() const {
  return view_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RecordEntryProto::view() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.RecordEntryProto.view)
  return _internal_view();
}
inline void RecordEntryProto::_internal_set_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  view_ = value;
}
inline void RecordEntryProto::set_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_view(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.RecordEntryProto.view)
}

// required .replication.ir.proto.OpID opid = 2;
inline bool RecordEntryProto::_internal_has_opid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || opid_ != nullptr);
  return value;
}
inline bool RecordEntryProto::has_opid() const {
  return _internal_has_opid();
}
inline void RecordEntryProto::clear_opid() {
  if (opid_ != nullptr) opid_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::replication::ir::proto::OpID& RecordEntryProto::_internal_opid() const {
  const ::replication::ir::proto::OpID* p = opid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::replication::ir::proto::OpID*>(
      &::replication::ir::proto::_OpID_default_instance_);
}
inline const ::replication::ir::proto::OpID& RecordEntryProto::opid() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.RecordEntryProto.opid)
  return _internal_opid();
}
inline void RecordEntryProto::unsafe_arena_set_allocated_opid(
    ::replication::ir::proto::OpID* opid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(opid_);
  }
  opid_ = opid;
  if (opid) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.RecordEntryProto.opid)
}
inline ::replication::ir::proto::OpID* RecordEntryProto::release_opid() {
  auto temp = unsafe_arena_release_opid();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::replication::ir::proto::OpID* RecordEntryProto::unsafe_arena_release_opid() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.RecordEntryProto.opid)
  _has_bits_[0] &= ~0x00000004u;
  ::replication::ir::proto::OpID* temp = opid_;
  opid_ = nullptr;
  return temp;
}
inline ::replication::ir::proto::OpID* RecordEntryProto::_internal_mutable_opid() {
  _has_bits_[0] |= 0x00000004u;
  if (opid_ == nullptr) {
    auto* p = CreateMaybeMessage<::replication::ir::proto::OpID>(GetArena());
    opid_ = p;
  }
  return opid_;
}
inline ::replication::ir::proto::OpID* RecordEntryProto::mutable_opid() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.RecordEntryProto.opid)
  return _internal_mutable_opid();
}
inline void RecordEntryProto::set_allocated_opid(::replication::ir::proto::OpID* opid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete opid_;
  }
  if (opid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(opid);
    if (message_arena != submessage_arena) {
      opid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  opid_ = opid;
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.RecordEntryProto.opid)
}

// required .replication.ir.proto.RecordEntryState state = 3;
inline bool RecordEntryProto::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RecordEntryProto::has_state() const {
  return _internal_has_state();
}
inline void RecordEntryProto::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::replication::ir::proto::RecordEntryState RecordEntryProto::_internal_state() const {
  return static_cast< ::replication::ir::proto::RecordEntryState >(state_);
}
inline ::replication::ir::proto::RecordEntryState RecordEntryProto::state() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.RecordEntryProto.state)
  return _internal_state();
}
inline void RecordEntryProto::_internal_set_state(::replication::ir::proto::RecordEntryState value) {
  assert(::replication::ir::proto::RecordEntryState_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  state_ = value;
}
inline void RecordEntryProto::set_state(::replication::ir::proto::RecordEntryState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.RecordEntryProto.state)
}

// required .replication.ir.proto.RecordEntryType type = 4;
inline bool RecordEntryProto::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RecordEntryProto::has_type() const {
  return _internal_has_type();
}
inline void RecordEntryProto::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::replication::ir::proto::RecordEntryType RecordEntryProto::_internal_type() const {
  return static_cast< ::replication::ir::proto::RecordEntryType >(type_);
}
inline ::replication::ir::proto::RecordEntryType RecordEntryProto::type() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.RecordEntryProto.type)
  return _internal_type();
}
inline void RecordEntryProto::_internal_set_type(::replication::ir::proto::RecordEntryType value) {
  assert(::replication::ir::proto::RecordEntryType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
}
inline void RecordEntryProto::set_type(::replication::ir::proto::RecordEntryType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.RecordEntryProto.type)
}

// required bytes op = 5;
inline bool RecordEntryProto::_internal_has_op() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RecordEntryProto::has_op() const {
  return _internal_has_op();
}
inline void RecordEntryProto::clear_op() {
  op_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordEntryProto::op() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.RecordEntryProto.op)
  return _internal_op();
}
inline void RecordEntryProto::set_op(const std::string& value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.RecordEntryProto.op)
}
inline std::string* RecordEntryProto::mutable_op() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.RecordEntryProto.op)
  return _internal_mutable_op();
}
inline const std::string& RecordEntryProto::_internal_op() const {
  return op_.Get();
}
inline void RecordEntryProto::_internal_set_op(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  op_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RecordEntryProto::set_op(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  op_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:replication.ir.proto.RecordEntryProto.op)
}
inline void RecordEntryProto::set_op(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  op_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:replication.ir.proto.RecordEntryProto.op)
}
inline void RecordEntryProto::set_op(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  op_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:replication.ir.proto.RecordEntryProto.op)
}
inline std::string* RecordEntryProto::_internal_mutable_op() {
  _has_bits_[0] |= 0x00000001u;
  return op_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RecordEntryProto::release_op() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.RecordEntryProto.op)
  if (!_internal_has_op()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return op_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RecordEntryProto::set_allocated_op(std::string* op) {
  if (op != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  op_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), op,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.RecordEntryProto.op)
}
inline std::string* RecordEntryProto::unsafe_arena_release_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:replication.ir.proto.RecordEntryProto.op)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return op_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RecordEntryProto::unsafe_arena_set_allocated_op(
    std::string* op) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (op != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  op_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      op, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.RecordEntryProto.op)
}

// required bytes result = 6;
inline bool RecordEntryProto::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RecordEntryProto::has_result() const {
  return _internal_has_result();
}
inline void RecordEntryProto::clear_result() {
  result_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RecordEntryProto::result() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.RecordEntryProto.result)
  return _internal_result();
}
inline void RecordEntryProto::set_result(const std::string& value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.RecordEntryProto.result)
}
inline std::string* RecordEntryProto::mutable_result() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.RecordEntryProto.result)
  return _internal_mutable_result();
}
inline const std::string& RecordEntryProto::_internal_result() const {
  return result_.Get();
}
inline void RecordEntryProto::_internal_set_result(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void RecordEntryProto::set_result(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  result_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:replication.ir.proto.RecordEntryProto.result)
}
inline void RecordEntryProto::set_result(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:replication.ir.proto.RecordEntryProto.result)
}
inline void RecordEntryProto::set_result(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:replication.ir.proto.RecordEntryProto.result)
}
inline std::string* RecordEntryProto::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000002u;
  return result_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* RecordEntryProto::release_result() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.RecordEntryProto.result)
  if (!_internal_has_result()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return result_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RecordEntryProto::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.RecordEntryProto.result)
}
inline std::string* RecordEntryProto::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:replication.ir.proto.RecordEntryProto.result)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return result_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void RecordEntryProto::unsafe_arena_set_allocated_result(
    std::string* result) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (result != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  result_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      result, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.RecordEntryProto.result)
}

// -------------------------------------------------------------------

// RecordProto

// repeated .replication.ir.proto.RecordEntryProto entry = 1;
inline int RecordProto::_internal_entry_size() const {
  return entry_.size();
}
inline int RecordProto::entry_size() const {
  return _internal_entry_size();
}
inline void RecordProto::clear_entry() {
  entry_.Clear();
}
inline ::replication::ir::proto::RecordEntryProto* RecordProto::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.RecordProto.entry)
  return entry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::replication::ir::proto::RecordEntryProto >*
RecordProto::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:replication.ir.proto.RecordProto.entry)
  return &entry_;
}
inline const ::replication::ir::proto::RecordEntryProto& RecordProto::_internal_entry(int index) const {
  return entry_.Get(index);
}
inline const ::replication::ir::proto::RecordEntryProto& RecordProto::entry(int index) const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.RecordProto.entry)
  return _internal_entry(index);
}
inline ::replication::ir::proto::RecordEntryProto* RecordProto::_internal_add_entry() {
  return entry_.Add();
}
inline ::replication::ir::proto::RecordEntryProto* RecordProto::add_entry() {
  // @@protoc_insertion_point(field_add:replication.ir.proto.RecordProto.entry)
  return _internal_add_entry();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::replication::ir::proto::RecordEntryProto >&
RecordProto::entry() const {
  // @@protoc_insertion_point(field_list:replication.ir.proto.RecordProto.entry)
  return entry_;
}

// -------------------------------------------------------------------

// ProposeInconsistentMessage

// required .replication.Request req = 1;
inline bool ProposeInconsistentMessage::_internal_has_req() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || req_ != nullptr);
  return value;
}
inline bool ProposeInconsistentMessage::has_req() const {
  return _internal_has_req();
}
inline const ::replication::Request& ProposeInconsistentMessage::_internal_req() const {
  const ::replication::Request* p = req_;
  return p != nullptr ? *p : *reinterpret_cast<const ::replication::Request*>(
      &::replication::_Request_default_instance_);
}
inline const ::replication::Request& ProposeInconsistentMessage::req() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ProposeInconsistentMessage.req)
  return _internal_req();
}
inline void ProposeInconsistentMessage::unsafe_arena_set_allocated_req(
    ::replication::Request* req) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.ProposeInconsistentMessage.req)
}
inline ::replication::Request* ProposeInconsistentMessage::release_req() {
  auto temp = unsafe_arena_release_req();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::replication::Request* ProposeInconsistentMessage::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.ProposeInconsistentMessage.req)
  _has_bits_[0] &= ~0x00000001u;
  ::replication::Request* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::replication::Request* ProposeInconsistentMessage::_internal_mutable_req() {
  _has_bits_[0] |= 0x00000001u;
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::replication::Request>(GetArena());
    req_ = p;
  }
  return req_;
}
inline ::replication::Request* ProposeInconsistentMessage::mutable_req() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.ProposeInconsistentMessage.req)
  return _internal_mutable_req();
}
inline void ProposeInconsistentMessage::set_allocated_req(::replication::Request* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req)->GetArena();
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.ProposeInconsistentMessage.req)
}

// -------------------------------------------------------------------

// ReplyInconsistentMessage

// required uint64 view = 1;
inline bool ReplyInconsistentMessage::_internal_has_view() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReplyInconsistentMessage::has_view() const {
  return _internal_has_view();
}
inline void ReplyInconsistentMessage::clear_view() {
  view_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReplyInconsistentMessage::_internal_view() const {
  return view_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReplyInconsistentMessage::view() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ReplyInconsistentMessage.view)
  return _internal_view();
}
inline void ReplyInconsistentMessage::_internal_set_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  view_ = value;
}
inline void ReplyInconsistentMessage::set_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_view(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.ReplyInconsistentMessage.view)
}

// required uint32 replicaIdx = 2;
inline bool ReplyInconsistentMessage::_internal_has_replicaidx() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReplyInconsistentMessage::has_replicaidx() const {
  return _internal_has_replicaidx();
}
inline void ReplyInconsistentMessage::clear_replicaidx() {
  replicaidx_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ReplyInconsistentMessage::_internal_replicaidx() const {
  return replicaidx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ReplyInconsistentMessage::replicaidx() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ReplyInconsistentMessage.replicaIdx)
  return _internal_replicaidx();
}
inline void ReplyInconsistentMessage::_internal_set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  replicaidx_ = value;
}
inline void ReplyInconsistentMessage::set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_replicaidx(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.ReplyInconsistentMessage.replicaIdx)
}

// required .replication.ir.proto.OpID opid = 3;
inline bool ReplyInconsistentMessage::_internal_has_opid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || opid_ != nullptr);
  return value;
}
inline bool ReplyInconsistentMessage::has_opid() const {
  return _internal_has_opid();
}
inline void ReplyInconsistentMessage::clear_opid() {
  if (opid_ != nullptr) opid_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::replication::ir::proto::OpID& ReplyInconsistentMessage::_internal_opid() const {
  const ::replication::ir::proto::OpID* p = opid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::replication::ir::proto::OpID*>(
      &::replication::ir::proto::_OpID_default_instance_);
}
inline const ::replication::ir::proto::OpID& ReplyInconsistentMessage::opid() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ReplyInconsistentMessage.opid)
  return _internal_opid();
}
inline void ReplyInconsistentMessage::unsafe_arena_set_allocated_opid(
    ::replication::ir::proto::OpID* opid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(opid_);
  }
  opid_ = opid;
  if (opid) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.ReplyInconsistentMessage.opid)
}
inline ::replication::ir::proto::OpID* ReplyInconsistentMessage::release_opid() {
  auto temp = unsafe_arena_release_opid();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::replication::ir::proto::OpID* ReplyInconsistentMessage::unsafe_arena_release_opid() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.ReplyInconsistentMessage.opid)
  _has_bits_[0] &= ~0x00000001u;
  ::replication::ir::proto::OpID* temp = opid_;
  opid_ = nullptr;
  return temp;
}
inline ::replication::ir::proto::OpID* ReplyInconsistentMessage::_internal_mutable_opid() {
  _has_bits_[0] |= 0x00000001u;
  if (opid_ == nullptr) {
    auto* p = CreateMaybeMessage<::replication::ir::proto::OpID>(GetArena());
    opid_ = p;
  }
  return opid_;
}
inline ::replication::ir::proto::OpID* ReplyInconsistentMessage::mutable_opid() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.ReplyInconsistentMessage.opid)
  return _internal_mutable_opid();
}
inline void ReplyInconsistentMessage::set_allocated_opid(::replication::ir::proto::OpID* opid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete opid_;
  }
  if (opid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(opid);
    if (message_arena != submessage_arena) {
      opid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  opid_ = opid;
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.ReplyInconsistentMessage.opid)
}

// required bool finalized = 4;
inline bool ReplyInconsistentMessage::_internal_has_finalized() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ReplyInconsistentMessage::has_finalized() const {
  return _internal_has_finalized();
}
inline void ReplyInconsistentMessage::clear_finalized() {
  finalized_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ReplyInconsistentMessage::_internal_finalized() const {
  return finalized_;
}
inline bool ReplyInconsistentMessage::finalized() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ReplyInconsistentMessage.finalized)
  return _internal_finalized();
}
inline void ReplyInconsistentMessage::_internal_set_finalized(bool value) {
  _has_bits_[0] |= 0x00000008u;
  finalized_ = value;
}
inline void ReplyInconsistentMessage::set_finalized(bool value) {
  _internal_set_finalized(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.ReplyInconsistentMessage.finalized)
}

// -------------------------------------------------------------------

// FinalizeInconsistentMessage

// required .replication.ir.proto.OpID opid = 1;
inline bool FinalizeInconsistentMessage::_internal_has_opid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || opid_ != nullptr);
  return value;
}
inline bool FinalizeInconsistentMessage::has_opid() const {
  return _internal_has_opid();
}
inline void FinalizeInconsistentMessage::clear_opid() {
  if (opid_ != nullptr) opid_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::replication::ir::proto::OpID& FinalizeInconsistentMessage::_internal_opid() const {
  const ::replication::ir::proto::OpID* p = opid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::replication::ir::proto::OpID*>(
      &::replication::ir::proto::_OpID_default_instance_);
}
inline const ::replication::ir::proto::OpID& FinalizeInconsistentMessage::opid() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.FinalizeInconsistentMessage.opid)
  return _internal_opid();
}
inline void FinalizeInconsistentMessage::unsafe_arena_set_allocated_opid(
    ::replication::ir::proto::OpID* opid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(opid_);
  }
  opid_ = opid;
  if (opid) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.FinalizeInconsistentMessage.opid)
}
inline ::replication::ir::proto::OpID* FinalizeInconsistentMessage::release_opid() {
  auto temp = unsafe_arena_release_opid();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::replication::ir::proto::OpID* FinalizeInconsistentMessage::unsafe_arena_release_opid() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.FinalizeInconsistentMessage.opid)
  _has_bits_[0] &= ~0x00000001u;
  ::replication::ir::proto::OpID* temp = opid_;
  opid_ = nullptr;
  return temp;
}
inline ::replication::ir::proto::OpID* FinalizeInconsistentMessage::_internal_mutable_opid() {
  _has_bits_[0] |= 0x00000001u;
  if (opid_ == nullptr) {
    auto* p = CreateMaybeMessage<::replication::ir::proto::OpID>(GetArena());
    opid_ = p;
  }
  return opid_;
}
inline ::replication::ir::proto::OpID* FinalizeInconsistentMessage::mutable_opid() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.FinalizeInconsistentMessage.opid)
  return _internal_mutable_opid();
}
inline void FinalizeInconsistentMessage::set_allocated_opid(::replication::ir::proto::OpID* opid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete opid_;
  }
  if (opid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(opid);
    if (message_arena != submessage_arena) {
      opid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  opid_ = opid;
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.FinalizeInconsistentMessage.opid)
}

// -------------------------------------------------------------------

// ConfirmMessage

// required uint64 view = 1;
inline bool ConfirmMessage::_internal_has_view() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfirmMessage::has_view() const {
  return _internal_has_view();
}
inline void ConfirmMessage::clear_view() {
  view_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ConfirmMessage::_internal_view() const {
  return view_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ConfirmMessage::view() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ConfirmMessage.view)
  return _internal_view();
}
inline void ConfirmMessage::_internal_set_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  view_ = value;
}
inline void ConfirmMessage::set_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_view(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.ConfirmMessage.view)
}

// required uint32 replicaIdx = 2;
inline bool ConfirmMessage::_internal_has_replicaidx() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfirmMessage::has_replicaidx() const {
  return _internal_has_replicaidx();
}
inline void ConfirmMessage::clear_replicaidx() {
  replicaidx_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ConfirmMessage::_internal_replicaidx() const {
  return replicaidx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ConfirmMessage::replicaidx() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ConfirmMessage.replicaIdx)
  return _internal_replicaidx();
}
inline void ConfirmMessage::_internal_set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  replicaidx_ = value;
}
inline void ConfirmMessage::set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_replicaidx(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.ConfirmMessage.replicaIdx)
}

// required .replication.ir.proto.OpID opid = 3;
inline bool ConfirmMessage::_internal_has_opid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || opid_ != nullptr);
  return value;
}
inline bool ConfirmMessage::has_opid() const {
  return _internal_has_opid();
}
inline void ConfirmMessage::clear_opid() {
  if (opid_ != nullptr) opid_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::replication::ir::proto::OpID& ConfirmMessage::_internal_opid() const {
  const ::replication::ir::proto::OpID* p = opid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::replication::ir::proto::OpID*>(
      &::replication::ir::proto::_OpID_default_instance_);
}
inline const ::replication::ir::proto::OpID& ConfirmMessage::opid() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ConfirmMessage.opid)
  return _internal_opid();
}
inline void ConfirmMessage::unsafe_arena_set_allocated_opid(
    ::replication::ir::proto::OpID* opid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(opid_);
  }
  opid_ = opid;
  if (opid) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.ConfirmMessage.opid)
}
inline ::replication::ir::proto::OpID* ConfirmMessage::release_opid() {
  auto temp = unsafe_arena_release_opid();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::replication::ir::proto::OpID* ConfirmMessage::unsafe_arena_release_opid() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.ConfirmMessage.opid)
  _has_bits_[0] &= ~0x00000001u;
  ::replication::ir::proto::OpID* temp = opid_;
  opid_ = nullptr;
  return temp;
}
inline ::replication::ir::proto::OpID* ConfirmMessage::_internal_mutable_opid() {
  _has_bits_[0] |= 0x00000001u;
  if (opid_ == nullptr) {
    auto* p = CreateMaybeMessage<::replication::ir::proto::OpID>(GetArena());
    opid_ = p;
  }
  return opid_;
}
inline ::replication::ir::proto::OpID* ConfirmMessage::mutable_opid() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.ConfirmMessage.opid)
  return _internal_mutable_opid();
}
inline void ConfirmMessage::set_allocated_opid(::replication::ir::proto::OpID* opid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete opid_;
  }
  if (opid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(opid);
    if (message_arena != submessage_arena) {
      opid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  opid_ = opid;
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.ConfirmMessage.opid)
}

// -------------------------------------------------------------------

// ProposeConsensusMessage

// required .replication.Request req = 1;
inline bool ProposeConsensusMessage::_internal_has_req() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || req_ != nullptr);
  return value;
}
inline bool ProposeConsensusMessage::has_req() const {
  return _internal_has_req();
}
inline const ::replication::Request& ProposeConsensusMessage::_internal_req() const {
  const ::replication::Request* p = req_;
  return p != nullptr ? *p : *reinterpret_cast<const ::replication::Request*>(
      &::replication::_Request_default_instance_);
}
inline const ::replication::Request& ProposeConsensusMessage::req() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ProposeConsensusMessage.req)
  return _internal_req();
}
inline void ProposeConsensusMessage::unsafe_arena_set_allocated_req(
    ::replication::Request* req) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.ProposeConsensusMessage.req)
}
inline ::replication::Request* ProposeConsensusMessage::release_req() {
  auto temp = unsafe_arena_release_req();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::replication::Request* ProposeConsensusMessage::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.ProposeConsensusMessage.req)
  _has_bits_[0] &= ~0x00000001u;
  ::replication::Request* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::replication::Request* ProposeConsensusMessage::_internal_mutable_req() {
  _has_bits_[0] |= 0x00000001u;
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::replication::Request>(GetArena());
    req_ = p;
  }
  return req_;
}
inline ::replication::Request* ProposeConsensusMessage::mutable_req() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.ProposeConsensusMessage.req)
  return _internal_mutable_req();
}
inline void ProposeConsensusMessage::set_allocated_req(::replication::Request* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req)->GetArena();
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.ProposeConsensusMessage.req)
}

// -------------------------------------------------------------------

// ReplyConsensusMessage

// required uint64 view = 1;
inline bool ReplyConsensusMessage::_internal_has_view() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReplyConsensusMessage::has_view() const {
  return _internal_has_view();
}
inline void ReplyConsensusMessage::clear_view() {
  view_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReplyConsensusMessage::_internal_view() const {
  return view_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReplyConsensusMessage::view() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ReplyConsensusMessage.view)
  return _internal_view();
}
inline void ReplyConsensusMessage::_internal_set_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  view_ = value;
}
inline void ReplyConsensusMessage::set_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_view(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.ReplyConsensusMessage.view)
}

// required uint32 replicaIdx = 2;
inline bool ReplyConsensusMessage::_internal_has_replicaidx() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ReplyConsensusMessage::has_replicaidx() const {
  return _internal_has_replicaidx();
}
inline void ReplyConsensusMessage::clear_replicaidx() {
  replicaidx_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ReplyConsensusMessage::_internal_replicaidx() const {
  return replicaidx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ReplyConsensusMessage::replicaidx() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ReplyConsensusMessage.replicaIdx)
  return _internal_replicaidx();
}
inline void ReplyConsensusMessage::_internal_set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  replicaidx_ = value;
}
inline void ReplyConsensusMessage::set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_replicaidx(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.ReplyConsensusMessage.replicaIdx)
}

// required .replication.ir.proto.OpID opid = 3;
inline bool ReplyConsensusMessage::_internal_has_opid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || opid_ != nullptr);
  return value;
}
inline bool ReplyConsensusMessage::has_opid() const {
  return _internal_has_opid();
}
inline void ReplyConsensusMessage::clear_opid() {
  if (opid_ != nullptr) opid_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::replication::ir::proto::OpID& ReplyConsensusMessage::_internal_opid() const {
  const ::replication::ir::proto::OpID* p = opid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::replication::ir::proto::OpID*>(
      &::replication::ir::proto::_OpID_default_instance_);
}
inline const ::replication::ir::proto::OpID& ReplyConsensusMessage::opid() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ReplyConsensusMessage.opid)
  return _internal_opid();
}
inline void ReplyConsensusMessage::unsafe_arena_set_allocated_opid(
    ::replication::ir::proto::OpID* opid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(opid_);
  }
  opid_ = opid;
  if (opid) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.ReplyConsensusMessage.opid)
}
inline ::replication::ir::proto::OpID* ReplyConsensusMessage::release_opid() {
  auto temp = unsafe_arena_release_opid();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::replication::ir::proto::OpID* ReplyConsensusMessage::unsafe_arena_release_opid() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.ReplyConsensusMessage.opid)
  _has_bits_[0] &= ~0x00000002u;
  ::replication::ir::proto::OpID* temp = opid_;
  opid_ = nullptr;
  return temp;
}
inline ::replication::ir::proto::OpID* ReplyConsensusMessage::_internal_mutable_opid() {
  _has_bits_[0] |= 0x00000002u;
  if (opid_ == nullptr) {
    auto* p = CreateMaybeMessage<::replication::ir::proto::OpID>(GetArena());
    opid_ = p;
  }
  return opid_;
}
inline ::replication::ir::proto::OpID* ReplyConsensusMessage::mutable_opid() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.ReplyConsensusMessage.opid)
  return _internal_mutable_opid();
}
inline void ReplyConsensusMessage::set_allocated_opid(::replication::ir::proto::OpID* opid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete opid_;
  }
  if (opid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(opid);
    if (message_arena != submessage_arena) {
      opid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  opid_ = opid;
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.ReplyConsensusMessage.opid)
}

// required bytes result = 4;
inline bool ReplyConsensusMessage::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReplyConsensusMessage::has_result() const {
  return _internal_has_result();
}
inline void ReplyConsensusMessage::clear_result() {
  result_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReplyConsensusMessage::result() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ReplyConsensusMessage.result)
  return _internal_result();
}
inline void ReplyConsensusMessage::set_result(const std::string& value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.ReplyConsensusMessage.result)
}
inline std::string* ReplyConsensusMessage::mutable_result() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.ReplyConsensusMessage.result)
  return _internal_mutable_result();
}
inline const std::string& ReplyConsensusMessage::_internal_result() const {
  return result_.Get();
}
inline void ReplyConsensusMessage::_internal_set_result(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ReplyConsensusMessage::set_result(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  result_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:replication.ir.proto.ReplyConsensusMessage.result)
}
inline void ReplyConsensusMessage::set_result(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:replication.ir.proto.ReplyConsensusMessage.result)
}
inline void ReplyConsensusMessage::set_result(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:replication.ir.proto.ReplyConsensusMessage.result)
}
inline std::string* ReplyConsensusMessage::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  return result_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ReplyConsensusMessage::release_result() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.ReplyConsensusMessage.result)
  if (!_internal_has_result()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return result_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ReplyConsensusMessage::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.ReplyConsensusMessage.result)
}
inline std::string* ReplyConsensusMessage::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:replication.ir.proto.ReplyConsensusMessage.result)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return result_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ReplyConsensusMessage::unsafe_arena_set_allocated_result(
    std::string* result) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (result != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      result, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.ReplyConsensusMessage.result)
}

// required bool finalized = 5;
inline bool ReplyConsensusMessage::_internal_has_finalized() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ReplyConsensusMessage::has_finalized() const {
  return _internal_has_finalized();
}
inline void ReplyConsensusMessage::clear_finalized() {
  finalized_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ReplyConsensusMessage::_internal_finalized() const {
  return finalized_;
}
inline bool ReplyConsensusMessage::finalized() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.ReplyConsensusMessage.finalized)
  return _internal_finalized();
}
inline void ReplyConsensusMessage::_internal_set_finalized(bool value) {
  _has_bits_[0] |= 0x00000010u;
  finalized_ = value;
}
inline void ReplyConsensusMessage::set_finalized(bool value) {
  _internal_set_finalized(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.ReplyConsensusMessage.finalized)
}

// -------------------------------------------------------------------

// FinalizeConsensusMessage

// required .replication.ir.proto.OpID opid = 1;
inline bool FinalizeConsensusMessage::_internal_has_opid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || opid_ != nullptr);
  return value;
}
inline bool FinalizeConsensusMessage::has_opid() const {
  return _internal_has_opid();
}
inline void FinalizeConsensusMessage::clear_opid() {
  if (opid_ != nullptr) opid_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::replication::ir::proto::OpID& FinalizeConsensusMessage::_internal_opid() const {
  const ::replication::ir::proto::OpID* p = opid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::replication::ir::proto::OpID*>(
      &::replication::ir::proto::_OpID_default_instance_);
}
inline const ::replication::ir::proto::OpID& FinalizeConsensusMessage::opid() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.FinalizeConsensusMessage.opid)
  return _internal_opid();
}
inline void FinalizeConsensusMessage::unsafe_arena_set_allocated_opid(
    ::replication::ir::proto::OpID* opid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(opid_);
  }
  opid_ = opid;
  if (opid) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.FinalizeConsensusMessage.opid)
}
inline ::replication::ir::proto::OpID* FinalizeConsensusMessage::release_opid() {
  auto temp = unsafe_arena_release_opid();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::replication::ir::proto::OpID* FinalizeConsensusMessage::unsafe_arena_release_opid() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.FinalizeConsensusMessage.opid)
  _has_bits_[0] &= ~0x00000002u;
  ::replication::ir::proto::OpID* temp = opid_;
  opid_ = nullptr;
  return temp;
}
inline ::replication::ir::proto::OpID* FinalizeConsensusMessage::_internal_mutable_opid() {
  _has_bits_[0] |= 0x00000002u;
  if (opid_ == nullptr) {
    auto* p = CreateMaybeMessage<::replication::ir::proto::OpID>(GetArena());
    opid_ = p;
  }
  return opid_;
}
inline ::replication::ir::proto::OpID* FinalizeConsensusMessage::mutable_opid() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.FinalizeConsensusMessage.opid)
  return _internal_mutable_opid();
}
inline void FinalizeConsensusMessage::set_allocated_opid(::replication::ir::proto::OpID* opid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete opid_;
  }
  if (opid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(opid);
    if (message_arena != submessage_arena) {
      opid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  opid_ = opid;
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.FinalizeConsensusMessage.opid)
}

// required bytes result = 2;
inline bool FinalizeConsensusMessage::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FinalizeConsensusMessage::has_result() const {
  return _internal_has_result();
}
inline void FinalizeConsensusMessage::clear_result() {
  result_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FinalizeConsensusMessage::result() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.FinalizeConsensusMessage.result)
  return _internal_result();
}
inline void FinalizeConsensusMessage::set_result(const std::string& value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.FinalizeConsensusMessage.result)
}
inline std::string* FinalizeConsensusMessage::mutable_result() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.FinalizeConsensusMessage.result)
  return _internal_mutable_result();
}
inline const std::string& FinalizeConsensusMessage::_internal_result() const {
  return result_.Get();
}
inline void FinalizeConsensusMessage::_internal_set_result(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FinalizeConsensusMessage::set_result(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  result_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:replication.ir.proto.FinalizeConsensusMessage.result)
}
inline void FinalizeConsensusMessage::set_result(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:replication.ir.proto.FinalizeConsensusMessage.result)
}
inline void FinalizeConsensusMessage::set_result(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:replication.ir.proto.FinalizeConsensusMessage.result)
}
inline std::string* FinalizeConsensusMessage::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  return result_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FinalizeConsensusMessage::release_result() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.FinalizeConsensusMessage.result)
  if (!_internal_has_result()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return result_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FinalizeConsensusMessage::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.FinalizeConsensusMessage.result)
}
inline std::string* FinalizeConsensusMessage::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_unsafe_arena_release:replication.ir.proto.FinalizeConsensusMessage.result)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return result_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void FinalizeConsensusMessage::unsafe_arena_set_allocated_result(
    std::string* result) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (result != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      result, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.FinalizeConsensusMessage.result)
}

// -------------------------------------------------------------------

// DoViewChangeMessage

// required uint32 replicaIdx = 1;
inline bool DoViewChangeMessage::_internal_has_replicaidx() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DoViewChangeMessage::has_replicaidx() const {
  return _internal_has_replicaidx();
}
inline void DoViewChangeMessage::clear_replicaidx() {
  replicaidx_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DoViewChangeMessage::_internal_replicaidx() const {
  return replicaidx_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DoViewChangeMessage::replicaidx() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.DoViewChangeMessage.replicaIdx)
  return _internal_replicaidx();
}
inline void DoViewChangeMessage::_internal_set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  replicaidx_ = value;
}
inline void DoViewChangeMessage::set_replicaidx(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_replicaidx(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.DoViewChangeMessage.replicaIdx)
}

// optional .replication.ir.proto.RecordProto record = 2;
inline bool DoViewChangeMessage::_internal_has_record() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || record_ != nullptr);
  return value;
}
inline bool DoViewChangeMessage::has_record() const {
  return _internal_has_record();
}
inline void DoViewChangeMessage::clear_record() {
  if (record_ != nullptr) record_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::replication::ir::proto::RecordProto& DoViewChangeMessage::_internal_record() const {
  const ::replication::ir::proto::RecordProto* p = record_;
  return p != nullptr ? *p : *reinterpret_cast<const ::replication::ir::proto::RecordProto*>(
      &::replication::ir::proto::_RecordProto_default_instance_);
}
inline const ::replication::ir::proto::RecordProto& DoViewChangeMessage::record() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.DoViewChangeMessage.record)
  return _internal_record();
}
inline void DoViewChangeMessage::unsafe_arena_set_allocated_record(
    ::replication::ir::proto::RecordProto* record) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(record_);
  }
  record_ = record;
  if (record) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.DoViewChangeMessage.record)
}
inline ::replication::ir::proto::RecordProto* DoViewChangeMessage::release_record() {
  auto temp = unsafe_arena_release_record();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::replication::ir::proto::RecordProto* DoViewChangeMessage::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.DoViewChangeMessage.record)
  _has_bits_[0] &= ~0x00000001u;
  ::replication::ir::proto::RecordProto* temp = record_;
  record_ = nullptr;
  return temp;
}
inline ::replication::ir::proto::RecordProto* DoViewChangeMessage::_internal_mutable_record() {
  _has_bits_[0] |= 0x00000001u;
  if (record_ == nullptr) {
    auto* p = CreateMaybeMessage<::replication::ir::proto::RecordProto>(GetArena());
    record_ = p;
  }
  return record_;
}
inline ::replication::ir::proto::RecordProto* DoViewChangeMessage::mutable_record() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.DoViewChangeMessage.record)
  return _internal_mutable_record();
}
inline void DoViewChangeMessage::set_allocated_record(::replication::ir::proto::RecordProto* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete record_;
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(record);
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  record_ = record;
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.DoViewChangeMessage.record)
}

// required uint64 new_view = 3;
inline bool DoViewChangeMessage::_internal_has_new_view() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DoViewChangeMessage::has_new_view() const {
  return _internal_has_new_view();
}
inline void DoViewChangeMessage::clear_new_view() {
  new_view_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DoViewChangeMessage::_internal_new_view() const {
  return new_view_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DoViewChangeMessage::new_view() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.DoViewChangeMessage.new_view)
  return _internal_new_view();
}
inline void DoViewChangeMessage::_internal_set_new_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  new_view_ = value;
}
inline void DoViewChangeMessage::set_new_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_new_view(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.DoViewChangeMessage.new_view)
}

// required uint64 latest_normal_view = 4;
inline bool DoViewChangeMessage::_internal_has_latest_normal_view() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DoViewChangeMessage::has_latest_normal_view() const {
  return _internal_has_latest_normal_view();
}
inline void DoViewChangeMessage::clear_latest_normal_view() {
  latest_normal_view_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DoViewChangeMessage::_internal_latest_normal_view() const {
  return latest_normal_view_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 DoViewChangeMessage::latest_normal_view() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.DoViewChangeMessage.latest_normal_view)
  return _internal_latest_normal_view();
}
inline void DoViewChangeMessage::_internal_set_latest_normal_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  latest_normal_view_ = value;
}
inline void DoViewChangeMessage::set_latest_normal_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_latest_normal_view(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.DoViewChangeMessage.latest_normal_view)
}

// -------------------------------------------------------------------

// StartViewMessage

// required .replication.ir.proto.RecordProto record = 1;
inline bool StartViewMessage::_internal_has_record() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || record_ != nullptr);
  return value;
}
inline bool StartViewMessage::has_record() const {
  return _internal_has_record();
}
inline void StartViewMessage::clear_record() {
  if (record_ != nullptr) record_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::replication::ir::proto::RecordProto& StartViewMessage::_internal_record() const {
  const ::replication::ir::proto::RecordProto* p = record_;
  return p != nullptr ? *p : *reinterpret_cast<const ::replication::ir::proto::RecordProto*>(
      &::replication::ir::proto::_RecordProto_default_instance_);
}
inline const ::replication::ir::proto::RecordProto& StartViewMessage::record() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.StartViewMessage.record)
  return _internal_record();
}
inline void StartViewMessage::unsafe_arena_set_allocated_record(
    ::replication::ir::proto::RecordProto* record) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(record_);
  }
  record_ = record;
  if (record) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.StartViewMessage.record)
}
inline ::replication::ir::proto::RecordProto* StartViewMessage::release_record() {
  auto temp = unsafe_arena_release_record();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::replication::ir::proto::RecordProto* StartViewMessage::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.StartViewMessage.record)
  _has_bits_[0] &= ~0x00000001u;
  ::replication::ir::proto::RecordProto* temp = record_;
  record_ = nullptr;
  return temp;
}
inline ::replication::ir::proto::RecordProto* StartViewMessage::_internal_mutable_record() {
  _has_bits_[0] |= 0x00000001u;
  if (record_ == nullptr) {
    auto* p = CreateMaybeMessage<::replication::ir::proto::RecordProto>(GetArena());
    record_ = p;
  }
  return record_;
}
inline ::replication::ir::proto::RecordProto* StartViewMessage::mutable_record() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.StartViewMessage.record)
  return _internal_mutable_record();
}
inline void StartViewMessage::set_allocated_record(::replication::ir::proto::RecordProto* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete record_;
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(record);
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  record_ = record;
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.StartViewMessage.record)
}

// required uint64 new_view = 2;
inline bool StartViewMessage::_internal_has_new_view() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StartViewMessage::has_new_view() const {
  return _internal_has_new_view();
}
inline void StartViewMessage::clear_new_view() {
  new_view_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StartViewMessage::_internal_new_view() const {
  return new_view_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StartViewMessage::new_view() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.StartViewMessage.new_view)
  return _internal_new_view();
}
inline void StartViewMessage::_internal_set_new_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  new_view_ = value;
}
inline void StartViewMessage::set_new_view(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_new_view(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.StartViewMessage.new_view)
}

// -------------------------------------------------------------------

// UnloggedRequestMessage

// required .replication.UnloggedRequest req = 1;
inline bool UnloggedRequestMessage::_internal_has_req() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || req_ != nullptr);
  return value;
}
inline bool UnloggedRequestMessage::has_req() const {
  return _internal_has_req();
}
inline const ::replication::UnloggedRequest& UnloggedRequestMessage::_internal_req() const {
  const ::replication::UnloggedRequest* p = req_;
  return p != nullptr ? *p : *reinterpret_cast<const ::replication::UnloggedRequest*>(
      &::replication::_UnloggedRequest_default_instance_);
}
inline const ::replication::UnloggedRequest& UnloggedRequestMessage::req() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.UnloggedRequestMessage.req)
  return _internal_req();
}
inline void UnloggedRequestMessage::unsafe_arena_set_allocated_req(
    ::replication::UnloggedRequest* req) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  req_ = req;
  if (req) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.UnloggedRequestMessage.req)
}
inline ::replication::UnloggedRequest* UnloggedRequestMessage::release_req() {
  auto temp = unsafe_arena_release_req();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::replication::UnloggedRequest* UnloggedRequestMessage::unsafe_arena_release_req() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.UnloggedRequestMessage.req)
  _has_bits_[0] &= ~0x00000001u;
  ::replication::UnloggedRequest* temp = req_;
  req_ = nullptr;
  return temp;
}
inline ::replication::UnloggedRequest* UnloggedRequestMessage::_internal_mutable_req() {
  _has_bits_[0] |= 0x00000001u;
  if (req_ == nullptr) {
    auto* p = CreateMaybeMessage<::replication::UnloggedRequest>(GetArena());
    req_ = p;
  }
  return req_;
}
inline ::replication::UnloggedRequest* UnloggedRequestMessage::mutable_req() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.UnloggedRequestMessage.req)
  return _internal_mutable_req();
}
inline void UnloggedRequestMessage::set_allocated_req(::replication::UnloggedRequest* req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(req_);
  }
  if (req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(req)->GetArena();
    if (message_arena != submessage_arena) {
      req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  req_ = req;
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.UnloggedRequestMessage.req)
}

// -------------------------------------------------------------------

// UnloggedReplyMessage

// required bytes reply = 1;
inline bool UnloggedReplyMessage::_internal_has_reply() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UnloggedReplyMessage::has_reply() const {
  return _internal_has_reply();
}
inline void UnloggedReplyMessage::clear_reply() {
  reply_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UnloggedReplyMessage::reply() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.UnloggedReplyMessage.reply)
  return _internal_reply();
}
inline void UnloggedReplyMessage::set_reply(const std::string& value) {
  _internal_set_reply(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.UnloggedReplyMessage.reply)
}
inline std::string* UnloggedReplyMessage::mutable_reply() {
  // @@protoc_insertion_point(field_mutable:replication.ir.proto.UnloggedReplyMessage.reply)
  return _internal_mutable_reply();
}
inline const std::string& UnloggedReplyMessage::_internal_reply() const {
  return reply_.Get();
}
inline void UnloggedReplyMessage::_internal_set_reply(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reply_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnloggedReplyMessage::set_reply(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  reply_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:replication.ir.proto.UnloggedReplyMessage.reply)
}
inline void UnloggedReplyMessage::set_reply(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  reply_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:replication.ir.proto.UnloggedReplyMessage.reply)
}
inline void UnloggedReplyMessage::set_reply(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  reply_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:replication.ir.proto.UnloggedReplyMessage.reply)
}
inline std::string* UnloggedReplyMessage::_internal_mutable_reply() {
  _has_bits_[0] |= 0x00000001u;
  return reply_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnloggedReplyMessage::release_reply() {
  // @@protoc_insertion_point(field_release:replication.ir.proto.UnloggedReplyMessage.reply)
  if (!_internal_has_reply()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return reply_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnloggedReplyMessage::set_allocated_reply(std::string* reply) {
  if (reply != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reply_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reply,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:replication.ir.proto.UnloggedReplyMessage.reply)
}
inline std::string* UnloggedReplyMessage::unsafe_arena_release_reply() {
  // @@protoc_insertion_point(field_unsafe_arena_release:replication.ir.proto.UnloggedReplyMessage.reply)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return reply_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UnloggedReplyMessage::unsafe_arena_set_allocated_reply(
    std::string* reply) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (reply != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reply_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      reply, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:replication.ir.proto.UnloggedReplyMessage.reply)
}

// required uint64 clientreqid = 2;
inline bool UnloggedReplyMessage::_internal_has_clientreqid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UnloggedReplyMessage::has_clientreqid() const {
  return _internal_has_clientreqid();
}
inline void UnloggedReplyMessage::clear_clientreqid() {
  clientreqid_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UnloggedReplyMessage::_internal_clientreqid() const {
  return clientreqid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UnloggedReplyMessage::clientreqid() const {
  // @@protoc_insertion_point(field_get:replication.ir.proto.UnloggedReplyMessage.clientreqid)
  return _internal_clientreqid();
}
inline void UnloggedReplyMessage::_internal_set_clientreqid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  clientreqid_ = value;
}
inline void UnloggedReplyMessage::set_clientreqid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_clientreqid(value);
  // @@protoc_insertion_point(field_set:replication.ir.proto.UnloggedReplyMessage.clientreqid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace ir
}  // namespace replication

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::replication::ir::proto::RecordEntryState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::replication::ir::proto::RecordEntryState>() {
  return ::replication::ir::proto::RecordEntryState_descriptor();
}
template <> struct is_proto_enum< ::replication::ir::proto::RecordEntryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::replication::ir::proto::RecordEntryType>() {
  return ::replication::ir::proto::RecordEntryType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_replication_2fir_2fir_2dproto_2eproto
